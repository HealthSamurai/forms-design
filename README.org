#+title: SDC DSL Rework
#+date: 2023-08-16
#+author: Stas Buldakov

* Goal

1. Make simplified DSL
2. Move from layered arch to only document structure
3. Make it a sugar for SDC Questionnaire
4. Convertible to FHIR Q/QR
5. Store in DB as meta resource

* Top Level

1. Remove Layers (Document, Layout, Finalize, Launch)
2. Keep only document
3. Remove added complexity from zen

* Decisions

** *Remove :keys on top level*

1) Rename to `:questions` as map:
   #+begin_src clojure
     LateVisitDocument
     {:type aidbox.sdc/form
      :questions {:question1 {...}}}
   #+end_src

   + semantic
   + easy to work from code perspective
   + hard to human read

2) Rename to `:fields` as map:

3) Rename to `:fields` as vector
   #+begin_src clojure
     LateVisitDocument
     {:type aidbox.sdc/form
      :fields [{:name "ahahha"} {}]}
   #+end_src

   + more human readable
   + layout generation

4) Rename to `:items` as vector
   * similar to fhir questionnaire

** *Fields `ids` generation*

1) Manual by key (in case we have map of questions)
   #+begin_src clojure
     LateVisitDocument
     {:type aidbox.sdc/form
      :questions {:basic-question {:label "Super basic question"}}}
   #+end_src

2) Manual by `:name` field (in case we have vector of questions)
   #+begin_src clojure
     LateVisitDocument
     {:type aidbox.sdc/form
      :questions [{:label "Super basic question"
                   :name :basic-question}]}
   #+end_src

3) Manual by :id field (in case we have vector of questions)

4) As key value pairs
#+begin_src clojure
  LateVisitDocument
  {:type aidbox.sdc/form
   :questions [:basic-question {:label "Super basic question"}
               :second-question {:label "Super basic question"}]}
#+end_src

   + questions order
   + check field key uniqueness


4) Generate from label
   #+begin_src clojure
     LateVisitDocument
     {:type aidbox.sdc/form
      :questions [{:label "Super basic question"}]}
   #+end_src

** *Field type*

1) Explicit type
   #+begin_src clojure
     VitalsDocument
     {:fields [{:name "super"
     	   :type "string"}]}
   #+end_src

2) Sometimes we can infer type from other keys

   1) "dropdown" from options
      #+begin_src clojure
	VitalsForm
	{:fields [{:name "choice"
		   :options [{:display "HHH" :code "yes"}]}]}
      #+end_src

   2) "quantity" field from :unit field
      #+begin_src clojure
	VitalsForm
	{:fields [{:name "weight"
		   :unit "kg"}]}
      #+end_src

   3) sometimes we can't infer type and we need explicitly set the type
      string, number inputs as example
      #+begin_src clojure
	VitalsForm
	{:fields [{:name "reason"
		   :type "string"}]
      #+end_src

3) infer data type from layout control
   #+begin_src clojure
     VitalsForm
     {:fields [{:label "reason"
     	   :type "dropdown"
     	   :options []}
     	  {:name "large-text"
     	   :type "text"}
               {:label "large text"
                :type "textarea"}
     	  {:name "number"
     	   :type "number"}
               {:name "answer"
                :type "checkbox"}
               {:name "range"
                :type "range"
                :step 1}
               {:type "radiobutton"
                :options [{:code 1 :display "..."}]}
               ]}
  #+end_src

   + switch, checkbox - both boolean
   + text, textarea - both string
   + radiobutton, dropdown - can they be plain types?

4) explicit data type and widget type (optional)
   #+begin_src clojure

     VitalsForm
     {:fields [{:label "reason"
     	   :type "boolean"}
     	  {:name "boolean 2"
     	   :type "boolean"
                :widget "switch"}
               ]}
   #+end_src

** *Question Grouping*
In old architecture we have subforms and even maps inside maps, that
can be used for question grouping

1) Control type "group" with recursive structure as fields
   #+begin_src clojure
     VitalsForm
     {:fields [{:name "blood-pressure"
     	   :type "group"
     	   :fields [{:name "systolic"}
     		    {:name "diastolic"}]
     	   }]}
   #+end_src

2) Infer by `:fields` key
   #+begin_src clojure
     VitalsForm
     {:fields [{:name "blood-pressure"
     	   :fields [{} {}]}]}
  #+end_src

** *Display When*

1) As additional key in lisp
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "label"
     	   :display-when (= (get-in [:patient :name]) "")}]}
   #+end_src

   + hard to store in DB

2) As additinal key in fhirpath
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "label"
     	   :display-when "patient.name = '123'"}]}
  #+end_src

   + familiar to fhir community

** *Enable When*
1) As additional key:
   #+begin_src clojure
     PHQ2PHQ9
     {:type aidbox.sdc/form
      :fields [{:name "PHQ9 Score"
                :id "phq-score"
                :enable-when "false" ;; always disabled (readonly)
                }
               {:name "Do you have depression?"
                :type "checkbox"
                :id "phq2-depression"
                :enable-when "this.feeling-tired = null"}]}

   #+end_src

** *Calculated fields*

1) Additional field with rule on top level:
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :rules {:bmi (+ (get :weight) (get :height))
              :fields [{:label "BMI"
     		   :name "bmi"}]}
   #+end_src

   This is current approach:
   + all rules in one place
   + not scalable, can't state the rule for nested fields
     and grouped items

2) Rule on the same level as field:
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "BMI"
     	   :rule (+ (get :weight) (get :height))}]}
   #+end_src

3) Under :value key
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "patient name"
     	   :value (get-in [:patinet :name])}]}
   #+end_src
** *Default (initial) values*

1) Allocated field for default value:
   #+begin_src clojure
     VitalsDocument
     {:type aidbox.sdc/form
      :fields [{:name "Gender"
     	   :initial-value {:display "Not selected"}
                :default-value {:display "Not selected"}
     	   :options [{:display "Male"}
     		     {:display "Female"}]}]}
   #+end_src

2) Under :value key

   #+begin_src clojure
     VitalsDocument
     {:type aidbox.sdc/form
      :fields [{:name "Gender"
     	   :value {:dispaly "Not selected"}]}
   #+end_src

   ?:
   How to distingiush this fields from calculated fields
** *Repeated questions*

1) With type group we can only add additional flag about repeating:

   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "patient"}
     	  {:name "blood pressure"
     	   :type "group"
     	   :repetablae true
     	   :fields [{:name "systolic"
     		     :type "number"}]}

   #+end_src

2) Every field can be repeatable

   #+begin_src clojure
     VitalsDocument
     {:fields [{:name "temperature"
     	   :repeats true
     	   :minItems 1
     	   :type "quantity"
     	   :unit "C"}]}
  #+end_src

** *Constraints*

1) each question type knows its constraints
   #+begin_src clojure
     VitalsForm
     {:type aidbox.sdc/form
      :fields [{:name "weight"
     	   :min 123}
     	  {:name "blood pressure"
                :repeats true
     	   :minItems 1}]}
  #+end_src


** *Extraction*

1) Template based

   Covers only Observation cases
   #+begin_src clojure
     VitalsDocument
     {:type aidbox.sdc/form
      :fields [{:id "temperature"
     	   :type "quantity"
     	   :extraction "observation"
     	   :coding [{:system "loinc" :code "112312"}]
     	   }]}
   #+end_src

   + where to get other fields for observation (subject, effectiveDate)
   + how to infer value type (or composite)


2) Inline template

   VitalsDocument
   #+begin_src clojure
     VitalsDocument
     {:type aidbox.sdc/form
      :fields [{:id "temp"
     	   :type "quantity"
     	   :extraction {:resourceType "Observation"
     			:valueQuantity {:unit "123" :value "this"}
     			:code {:system "loinc" :code "123123"}}}
     	  ]}
#+end_src

   + boilerplate

** *Layout*

In simple case we have one column with all fields
What if I want to place my fields in a row?

1) Special control type as 'group'
   #+begin_src clojure
     {:type aidbox.sdc/form
      :fields [{:id "blood-pressure"
     	   :widget "row"}
   #+end_src

2) Special key in group control

   #+begin_src clojure
     {:type aidbox.sdc/form
      :fields [{:id "blood-pressure"
     	   :type "group"
     	   :direction "row"}]}
   #+end_src

3) Optional key in each widget telling about control size:
   #+begin_src clojure
     {:type aibox.sdc/form
      :fields [{:id "blood-pressure"
     	   :type "group"
     	   :fields [{:id "systolic"
                          :size 6}
                         {:id "diastolic"
                          :size 6}]}
               ]

   #+end_src

   Whole page divided into equal 12 columns. By default
   each field takes 12 columns. But we can say, how many columns
   should take this field. Like, say systolic and diastolic:
   take 6 of 12 columns.

   +--------+---------+
   |systolic|diastolic|
   +--------+---------+
   |   temperature     |
   +--------+---------+

   And with this approach we can provide better mobile support.
** *Prefill*
1) Use prefill key:

#+begin_src clojure
  VitalsDocument
  {:type aidbox.sdc/form
   :fields [{:name "Weight"
             :id "weight"
             :prefill "Patient.observation(code='weight').valueQuantity.value"}]}
#+end_src

** *Form Pieces Reuse (subforms)*

1) Not use form pieces
   a lot of boilerplate code

2) Special type for field template
   #+begin_src clojure
     LL358-3
     {:type aidbox.sdc/template
      :name "some name here"
      :id "paste id here"
      :extraction {:resourceType "Observation"
                   :valueCoding "this.value"
                   :code "this.coding.0"}
      :options [{:display "Not at all" :code "LA6568-5" :score 0}
                {:display "Several days" :code "LA6568-5" :score 1}
                {:display "More than half the days" :code "LA6568-5" :score 2}
                {:display "Nearly every day" :code "LA6568-5" :score 3}]}
   #+end_src

   Then use it via "/use/"|"/template/" key. Keys will be merged
   #+begin_src clojure
     PHQ2Form
     {:type aidbox.sdc/form
      :fields [{:use LL358-3
                :name "Feeling bad about yourself"
                :id "feeling-bad"
                :code [...]}
               {:template LL358-3
                :name "Thoughts you would be better off dead"
                :id "feeling-bad"
                :code [..]}
   #+end_src

** *Default form fields*

Current implementation has several always-presented fields: `author`, `patient`, `encounter`

** *How to store in DB*

1) Stored form should be the same as DSL?
2) Should we store meta data (as in QuestionnaireResponse: question text, code)?



* Form examples applying this rules

** *Vitals*
#+begin_src clojure
  VitalsDocument
  {:type aidbox.sdc/form
   :fields [{:name "Temperature"
             :id "temp"
             :repeats true
             :unit "F"
             :type "number"
             :min 86
             :max 105}
            {:name "Blood Pressure"
             :id "blood-pressure"
             :repeats true
             :fields [{:name "BP Sys" :id "systolic"
                       :unit "mmHg"
                       :min 40
                       :max 300}
                      {:name "BP dias"
                       :id "diastolic"
                       :unit "mmHg"
                       :min 20
                       :max 220}
                      {:name "Arm"
                       :id "arm"
                       :options [{:display "Biceps left"
                                  :code "LA11158-5"}
                                 {:display "Biceps Right"
                                  :code "LA11159-3"}]}
                      {:name "Position"
                       :id "position"
                       :options [{:display "Sitting"
                                  :code "LA11868-9"}
                                 {:display "Lying"
                                  :code "LA11868-9"}
                                 {:display "Standing"
                                  :code "LA11868-9"}]}]}
            {:name "Respiratory rate"
             :id "bpm"
             :repeats true
             :unit "bpm"
             :min 6 :max 60}
            {:name "Saturation"
             :id "saturation"
             :unit "SaO2 % PulseOx"
             :repeats true
             :min 60 :max 100}
            {:name "Heart Rate"
             :id "heart-rate"
             :unit "bpm"
             :repeats true
             :min 30 :max 250}
            {:name "BMI"
             :id "bmi"
             :type "number"
             :enable "false"
             :value "globalThis.weight.value / globalThis.height.value"}
            {:name "Weight"
             :id "weight"
             :unit "kg"}
            {:name "Height"
             :id "height"
             :unit "cm"}]}


#+end_src


** *PHQ2/PHQ9*

#+begin_src clojure
  LL358-3
  {:type aidbox.sdc/template
   :id "replace this"
   :name "replace this"
   :options [{:display "Not at all" :code "LA6568-5" :score 0}
             {:display "Several days" :code "LA6569-3" :score 1}
             {:display "More than half the days" :code "LA6570-1" :score 2}
             {:display "Nearly every day" :code "LA6571-9" :score 3}]}

  PHQ2PHQ9
  {:type "aidbox.sdc/form"
   :fields [{:type "label"
             :label "Over the past 2 weeks, how often have you been bothered by:"}
            {:template LL358-3
             :name "Feeling down, depressed or hopeless"
             :id "feeling-down"}
            {:template LL358-3
             :name "Little interest or pleasure in doing things"
             :id "little-interest"}
            {:type "group"
             :id "phq9-questions"
             :enable "this.little-interest + this.feeling-down >= 3"
             :fields  [{:template LL358-3
                        :name "Feeling bad about yourself"
                        :id "feeling-bad"}
                       {:template LL358-3
                        :name "Thoughts that you would be better off dead"
                        :id "thoughts"}
                       {:template LL358-3
                        :name "Poor appetite or overeating"
                        :id "poor-appetite"}
                       {:template LL358-3
                        :name "Trouble concentrating on things"
                        :id "trouble-concentrating"}

                       {:template LL358-3
                        :name "Trouble falling or staying asleep"
                        :id "trouble-sleep"}

                       {:template LL358-3
                        :name "Feeling tired or having little energy"
                        :id "feeling-tired"}
                       {:template LL358-3
                        :name "Moving or speaking so slowly"
                        :id "moving-slowly"}]}
            {:id "total-score"
             :name "PHQ2/9 Total Score"
             :value "this.feeling-down.score + this.little-interest.score + this.feeling-bad.score"}
            {:id "score-interp"
             :name "Score Interpretation"
             :value "if(this.feeling-down.score) some value"}
            ]}
#+end_src
